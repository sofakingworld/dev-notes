# Пишем конфиг в Elixir приложениях

В этой статье мы разберем, какой подход к конфигурированию приложения предпочтительнее выбирать, стоит ли придерживаться каких-либо стандартов в этом деле или нет

## Как обычно делают (Способ 1)

В большинстве случаев конфиг пишется по наитию, начинается со слова конфиг, потом дописывается какой-нибудь осмысленный атом, и третий параметр - структура с какими-либо значениями.

Пример:
```elixir
config :my_app, :slack,
  url: "https://hooks.slack.com",
  webhook: System.get_env("SLACK_WEBHOOK"),
  timeout: 15,
  emoji: ":ghost:"
```

Дальше где-то в модуле это все вытаскивается таким образом:

```elixir
Application.get_env(:my_app, :slack)[:webhook]
```

## Плюсы и минусы такого подхода

Один из главных минусов - нет привязки к модулю, в итоге нет точного понимания, какой модуль использует данный конфиг.

Второй минус вытекает из первого - мы не знаем, сколько модулей использует данный конфиг. Возможно конфиг используется несколькими модулями, это может быть плюсом, но только в случае, если модули используют параметры одинаково. 

Проблемы начнутся, например, когда обоим модулям нужен параметр `url`, но одному он нужен со схемой `(http, https)`, а другому нет.

----

## Как можно делать (Способ 2)

Думаю, уже по предыдущим абзацам стало ясно, к чему я веду. Вместо атома можно использовать название модуля.

Пример:
```elixir
config :my_app, MyApp.Integrations.SlackNotification,
  url: "https://hooks.slack.com",
  webhook: System.get_env("SLACK_WEBHOOK"),
  timeout: 15,
  emoji: ":ghost:"
```

Теперь мы знаем, что конфиг ссылается на модуль `MyApp.Integrations.SlackNotification`, можем сделать вывод, что конфиг используется в уведомлениях и знаем, в каком конкретно модуле.

Если мы придерживаемся такого правила при написании конфига, то в дальнейшем мы можем облегчить себе работу с конфигом, получать его более удобным способом.

Для этого на уровне приложения нужно объявить **следующий макрос**:
```elixir
defmodule MyApp do
  defmacro get_module_config(key) do
    quote do
      Application.get_env(:my_app, __MODULE__)[unquote(key)]
    end
  end
end
```

Теперь в модуле `MyApp.Integrations.SlackNotification` вместо `Application.get_env(:my_app, :slack)[:webhook]` мы можем написать:

```elixir
defmodule MyApp.Integrations.SlackNotification do
  require MyApp
  ...

  def send(text) do
    url = MyApp.get_module_config(:url)
    timeout = MyApp.get_module_config(:timeout)
    ...
  end
end
```

Получается, мы добавили немного абстракции, которая позволяет стандартизировать работу с конфигом и как следствие - упросить работу по его получению.


## Плюсы и минусы такого подхода

У данного подхода есть пара минусов: мы добавили лишнюю абстракцию и лишили себя возможности использовать один и тот же конфиг в нескольких модулях.

Но на самом деле из минусов вытекают плюсы:
- Теперь мы знаем, в каком модуле конфиг используется
- Если конфиг пытается перетечь в несколько модулей, то возможно, стоит пересмотреть архитектуру этих модулей и выделить какой-нибудь главный модуль, который будет хранить основной конфиг.

Например, у нас появилась необходимость отправлять уведомления с помощью другого вебхука или с другой emoji (например в другой workspace slack'а), при реализации конфига **первым способом** с большой вероятностью наш конфиг превратился бы в такой:

```elixir
config :my_app, :slack,
  url: "https://hooks.slack.com",
  timeout: 15,
  webhook_1: System.get_env("SLACK_WEBHOOK_1"),
  emoji_1: ":ghost:"
  webhook_2: System.get_env("SLACK_WEBHOOK_2"),
  emoji_2: ":beer:"
```

**Второй способ** добавил немного строгости и в **худшем случае** конфиг будет следующий:

```elixir
config :my_app, MyApp.Integrations.SlackNotification1,
  url: "https://hooks.slack.com",
  webhook: System.get_env("SLACK_WEBHOOK_1"),
  timeout: 15,
  emoji: ":ghost:"

config :my_app, MyApp.Integrations.SlackNotification2,
  url: "https://hooks.slack.com",
  webhook: System.get_env("SLACK_WEBHOOK_2"),
  timeout: 15,
  emoji: ":beer:"
```

**В лучшем**, программист разобьет модуль интеграции на несколько составляющих, чтобы избежать дублирования конфига:

```elixir
config :my_app, MyApp.Integrations.SlackNotificationBase,
  timeout: 15, 
  url: "https://hooks.slack.com"

config :my_app, MyApp.Integrations.SlackNotification1,
  webhook: System.get_env("SLACK_WEBHOOK_1"),
  emoji: ":ghost:"

config :my_app, MyApp.Integrations.SlackNotification2,
  webhook: System.get_env("SLACK_WEBHOOK_2"),
  emoji: ":beer:"
```
----

# Выводы

Для подведения итогов я составил таблицу, с указанием, какие возможности дает тот или иной подход. 

Я, однозначно, выбираю и использую в своих проектах второй способ, потому что он добавляет прозрачность и стандартизирует подход.

| -         | Способ 1       | Способ 2 |
| ----------| ------------- | ------------- |
| Переиспользование конфига в разных модулях  | ✅  | ❌ |
| Побуждает к разбиению модулей  | ❌  | ✅ |
| Понимание, где используется конфиг | ❌  | ✅ |
| Нет лишних абстракций | ✅  | ❌ |
